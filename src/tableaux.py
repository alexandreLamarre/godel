'''
@file : tableaux.py
Reference : https://www.coli.uni-saarland.de/projects/milca/courses/comsem/html/node148.html

## Definition 

Tableaux are data structures used in refutation based procedures
for automated theorem proving.

Tableau are trees labeled with formulae. 

They are constructed starting from a single (root) node, which is 
labeled with an input formula.

From this node, a tree is constructed by recursively decomposing
complex formulae along the lines of their logical connectives.

Finally the literals on each branch of this tree tell us what has 
to be true and what has to be false.

@note : In some class of models of the input formula, 
and (this is an important point) all branches of the 
tableaux taken together represent all models of the input formula.

If a branch of a tableau contains a contradiction : e.g.  q & ~q,
this branch is called *closed*. 
Branches that are not called closed are called *open*.

No models correspond to a closed branch 
(because two contradictory literals cannot be true in any model)

If all branches of a tableaux are closed, we're sure that there is 
no model at all for its input formula. This is a direct consequence 
of the fact that a tableaux enumerates all models of the input formula.

## Theorem Proving

When trying to prove that a formula is a theorem, we want to show
that the formula is true in *all* models. 

We can show the negation is true instead : 
we will show that there is no model for its negation.

We start with the negation of our suspected theorem, and construct a tableaux 
by decomposing it into subformulas step by step. To prove that it really is 
a theorem if we have to arrive at a closed tableaux at some point.

## Example Construction

Show that :
```
~(( p | q) & (~p & ~q))
```

All Formula in tableau calculus should be signed T/F 
at the top level, so our statement in the root becomes

```
(~(( p | q) & (~p & ~q)))F
```

Then we have to expand all formulas in the nodes as true so node 1 becomes

1: (( p | q) & (~p & ~q))T

Now we mark (1) as already expanded

The sign T, tells use we have to make this true, we can do this by 
making both of its conjuncts true :


(1) First expands into : 
    2 : (p | q)T
    3 : ~(p | q)T

Now we need to expand (2) and (3) into their respective branches.

For (2) There are two possibilities: Either p is true or q is true. 
We express this in a tableaux by introducing a branching (we call this a disjunctive expansion):

(2) Expands into :
    (4) : (~p & ~q)T

Then we expand (4) (this formula is true if all subformula are true) :
    (5) : pT
    (6) : qT
    

## Formalization

- The calculus of analytical tableaux analyzes a formula in a tree 
that represents a set of case distinctions for satisfiability.

- The calculus we will use acts on **signed** formulas : a formula decorated
with an intended truth value

- A formula AT signifies the calculus tries to satisfy the formula A, whereas
AF shows that the calculus trie to refute it.

- The tableau proving process starts with an **initial tableau**, that contains
only one node with on signed formula.

- The tableau is then generated by applying the following inference rules :

- (A & B)T
     |
    (A)T
     |
    (B)T

- (A & B)F
     |
    ___
   |   |
   AF  BF

- ~(A)T
    |
    AF

- ~(A)F
    |
    AT

- (α != β)
    (A)α
    (A)β
     |
  `CLOSED`

- A branch in a tableau is `CLOSED` iff it contains the `CLOSED` symbol
- A tableau is `CLOSED` iff all branches are `CLOSED`
- We will call a branch and also a complete tableau `SATURATED` if no rule can be applied to it
- We also apply the convention that no occurrence of a formula is expanded more than once

ALl of the above ensures that a tableau construction process always terminates (at least for PLNQ)
'''

from dataclasses import dataclass


@dataclass
class TableauNode:
    value: int


@dataclass
class Tableau:
    root: TableauNode
